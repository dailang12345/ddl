## 1.数据库事务的四个特性（ACID）
**1）原子性：** 简单理解，原子是化学变化中的最小单位，具有不可分割性。事务也是数据库中的最小的逻辑单元。

具有原子性，是指一个事务中的操作，要么全部操作成功，要么操作失败全部回滚。【原子操作能够保证线程安全。非原子操作可以通过sychronized使同步、保证安全】

成功必须要完全应用到数据库，失败则不能对数据库产生影响。

**2）一致性：** 
是指事务执行的结果必须是使数据库从一个一致性状态变到另一个一致性状态。保证数据库一致性是指当事务完成时，必须使所有数据都具有一致的状态。
如A与B之间的转账，是两者之间的操作，转账前两人的钱数总和为5000元，转账之后，钱数总和仍为5000

读一致性也是数据库一致性的一个重要方面。

情况一：我们对表中的数据进行了更新，但未提交时，另一个用户来读取表中的数据，这时候他读取到的是更新前的值。因为在DBMS中设有==临时表==,它用来保存修改前的值,在没有进行提交前读取数据,会读取临时表中的数据,这样一来就保证了数据是一致的.(当前用户看到的是更新前的值)

情况二：用户user1对表进行更新操作但是未提交，user2开始读取表中的数据，读取大量的数据，持续时间为（3分钟），这个过程中user1进行了提交操作。这个时候DBMS就要保证有足够大的临时表来存放修改前的数值,,以保证user2读取的数据是++修改前++的一致数据.然后下次再读取时候就是更新后的数据了。

==此处的读一致性涉及数据库的隔离级别，后续讨论==

**3）隔离性**
当多个用户并发访问数据库时，数据库为每一个用户开启的事务，不被其他事务的操作所干扰，多个并发事务之间要相互隔离。

即要达到这么一种效果：对于任意两个并发的事务T1和T2，在事务T1看来，T2要么在T1开始之前就已经结束，要么在T1结束之后才开始，这样每个事务都感觉不到有其他事务在并发地执行。

**4）持久性** 

一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便在数据库系统遇到故障的情况下也不会丢失事物的操作。

例如我们在使用JDBC操作数据库时，在提交事务方法后，提示用户事务操作完成，当我们程序执行完成直到看到提示后，就可以认定事务以及正确提交，即使这时候数据库出现了问题，也必须要将我们的事务完全执行完成。

## 数据库的隔离级别 

在==关系型数据库==中，所有的规则必须应用到事务的修改上，以便维护所有数据的完整性。


数据库的隔离级别 | 会出现的问题 | Mysql | Oracle、SQLServer、 DB2、PostgreSQL
---|---|---|---
读未提交 | 脏读、不可重复读、幻读 |
读已提交 | 不可重复读、幻读 | |默认
可重复读 | 幻读 | 默认
串行化 | | | 

####   四种隔离级别
1. 读未提交：写数据的时候加锁，只拒绝其他写操作，但不拒绝读操作。【可能读到别人未提交的数据】避免了多人同时进行写数据而导致的问题，但可能造成写数据过程中，有人读取，与写数据过程完成（过程中可能回滚了）后，该人再次读取到的数据不一致的问题。这就是读取了别人未提交的数据，即脏读。解决了”更新丢失”。
1. 读已提交：写数据时，禁止其它读写事务。【只能读到别人已提交的数据】读操作的锁（基于查询）是读取之后立即释放，所以在事务a读取完没有提交之前，其他事物有可能会修改这些数据，从而使得事务a再次执行相同查询时，读到的数据前后不一致。解决”脏读”和”更新丢失” ，可能出现 不可重复读的问题。
1. 可重复读 ：读操作时，不拒绝别人读操作。【可能读到别人正在读的数据】读操作的锁（基于事务）是直到事务提交之后才释放。读事务禁止其它写事务(允许读)。解决”不可重复读”、”更新丢失”和”脏读”。但可能出现幻读的问题。

1. 串行化 ：提供严格的事务隔离。【不能交叉】它要求事务序列化执行，事务只能一个接着一个地执行，但不能并发执行。

####  三种可能导致的问题

1. 脏读：一个事务读取了另一个事务未提交的数据,而这个数据是有可能回滚
1. 不可重复读：不可重复读意味着，在数据库访问中，一个事务范围内两个相同的查询却返回了不同数据。这是由于查询时系统中其他事务修改的提交而引起的。
1. 幻读：是指当事务不是独立执行时发生的一种现象，例如第一个事务对一个表中的数据进行了修改，这种修改涉及到表中的全部数据行。同时，第二个事务也修改这个表中的数据，这种修改是向表中插入一行新数据。那么，以后就会发生操作第一个事务的用户发现表中还有没有修改的数据行，就好象发生了幻觉一样.


